---
aliases: 
created: 2022-05-10, 5:50:00 pm (Tuesday, May 10th)
updated: 2022-05-10, 6:17:42 pm (Tuesday, May 10th)
---
[source](https://ferd.ca/complexity-has-to-live-somewhere.html)

This idea of "complexity has to live somewhere" reminds me of the [law of conservation of energy](https://energyeducation.ca/encyclopedia/Law_of_conservation_of_energy).
The conservation of energy states that energy is neither created nor destroyed, only converted from one form to another.
I feel like complexity in systems is similar, least with the perspective the author provides.

Maybe it's just the timing, but I feel this message has some overlap with the [[Reading/Articles/Programming Style Influences|Programming Style Influences]] article I just read.
In the Influences article, the author discussed how their style has changed after being exposed to a different codebase, Open BSD's.
Their style went from one that embraced verbose names, the use of white space, and simplicity as attempts to make code more readable and easier to understand.
In this Complexity article, the thought of simplicity "is fraught with peril because complexity can't be removed: it can just be shifted around."

I believe another argument in favor of this is considering the impact of spreading the complexity around.
This brings us to the Influence author's perspective of embracing the style of short and slightly cryptic code provides the ability to gain a better overview of the functionality since the code is more densely packed.
If the code is verbose and spaced out then you'd have to move around a lot to get a better understanding of what's going on.

These ideas are really interesting.
It's like comparing different ways of understanding material.
There is no right or wrong here.
Just trade-offs and opinions.

I was of the opinion of verbose code being preferable because I perceived it as easier to load into my working memory.
I cannot recall terse cryptic code where I felt the pros outweighed the cons.
But perhaps it's because I have not been exposed to enough of that type of coding.
Likewise here, perhaps I have this mindset of "make things as simple as possible" because I haven't been exposed to complex systems enough to understand that "complexity has to live somewhere" intuitively.

I think I'm also thinking of this a bit too much in a binary way.
While complexity definitely does have to live somewhere, that doesn't mean it can't be broken down into simpler pieces that work together, no?
While I guess this goes against the Influence author's take, since the overarching model is spread out amongst more places, could that not be seen akin to building upon first principles?
We programmers start off by learning a few primitive data structures and some ways to manipulate those structures.
Then we use that to build things like what we're using right now; computers, mobile phones, tablets, even this app!
Even the things web developers create are built upon abstractions, complexities broken down into smaller bits.
Perhaps my perspective is stuck in a certain direction?

Like most things, I believe there's a balance to be discussed here.
There are various degrees of complexity that we can perceive.
Likewise, there are various opinions on what complexity means or looks like.
Guess now we're talking about meta-complexity huh?
This definitely is not something with a one-size-fits-all solution.
However, I think the real interesting part is observing how people's perceptions and opinions on complexity change over time, whether from being exposed to more complex systems or through creating complexity.

Side: I thought the [law of requisite variety](http://pespmc1.vub.ac.be/REQVAR.html) addition was cool.

I guess that's another interesting thought: the difference in perceived complexity through either being exposed to existing complexity versus creating it yourself (accidentally or not).